///! This file is generated by https://github.com/yczhangsjtu/voproof-rust/voproof-scripts/__init__.py
use super::*;

#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct FibonacciProverKey<E: PairingEngine> {
  pub verifier_key: FibonacciVerifierKey<E>,
  pub powers: Vec<E::G1Affine>,
  pub max_degree: u64,
  
}

#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct FibonacciVerifierKey<E: PairingEngine> {
  
  pub kzg_vk: VerifierKey<E>,
  pub size: FibonacciSize,
  pub degree_bound: u64,
}

#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct FibonacciProof<E: PairingEngine> {pub cm_w_vec: Commitment<E>,
    pub cm_t_vec: Commitment<E>,
    pub cm_h_vec_1: Commitment<E>,
    pub cm_h_vec_2: Commitment<E>,
    pub y: E::ScalarField,
    pub cap_w: KZGProof<E>,
    pub cap_w_1: KZGProof<E>,}

pub struct VOProofFibonacci {}

impl<E: PairingEngine> SNARKProverKey<E> for FibonacciProverKey<E> {}

impl<E: PairingEngine> SNARKVerifierKey<E> for FibonacciVerifierKey<E> {}

impl<E: PairingEngine> SNARKProof<E> for FibonacciProof<E> {}

impl VOProofFibonacci {
  pub fn get_max_degree(size: FibonacciSize) -> usize {
    ((size.n as i64) + 2) as usize
  }
}

impl<E: PairingEngine> SNARK<E> for VOProofFibonacci {
  type Size = FibonacciSize;
  type CS = Fibonacci<E::ScalarField>;
  type PK = FibonacciProverKey<E>;
  type VK = FibonacciVerifierKey<E>;
  type Ins = FibonacciInstance<E::ScalarField>;
  type Wit = FibonacciWitness<E::ScalarField>;
  type Pf = FibonacciProof<E>;

  fn setup(size: usize) -> Result<UniversalParams<E>, Error> {
    let rng = &mut test_rng();
    KZG10::<E, DensePoly<E::ScalarField>>::setup(size, rng)
  }

  fn index(
    pp: &UniversalParams<E>,
    cs: &Fibonacci<E::ScalarField>,
  ) -> Result<(FibonacciProverKey<E>, FibonacciVerifierKey<E>), Error> {
    let max_degree = Self::get_max_degree(cs.get_size());
    let cap_d = pp.powers_of_g.len();
    assert!(cap_d > max_degree);

    let powers_of_g = pp.powers_of_g[..].to_vec();
    let size = cs.get_size();
    init_size!(
          n,
          n,
          size);
        define_generator!(
          gamma,
          E);
        
    let verifier_key = FibonacciVerifierKey::<E> {
      
      kzg_vk: VerifierKey {
        g: pp.powers_of_g[0],
        h: pp.h,
        beta_h: pp.beta_h,
        prepared_h: pp.prepared_h.clone(),
        prepared_beta_h: pp.prepared_beta_h.clone(),
      },
      size,
      degree_bound: cap_d as u64,
    };
    Ok((
      FibonacciProverKey::<E> {
        verifier_key: verifier_key.clone(),
        powers: powers_of_g,
        max_degree: max_degree as u64,
        
      },
      verifier_key,
    ))
  }
  fn prove(pk: &Self::PK, x: &Self::Ins, w: &Self::Wit) -> Result<Self::Pf, Error> {
    let size = pk.verifier_key.size.clone();
    let vk = pk.verifier_key.clone();
    let cap_d = pk.verifier_key.degree_bound as i64;
    let rng = &mut test_rng();
    init_size!(
          n,
          n,
          size);
        define_generator!(
          gamma,
          E);
        sample_randomizers!(
          rng,
          delta_vec,
          1,
          delta_vec_1,
          1);
        init_size!(
          n,
          n,
          size);
        define!(
          a,
          x.a);
        define!(
          b,
          x.b);
        define!(
          c,
          x.c);
        define!(
          aplus2b,
          a + scalar_to_field!(2)*b);
        define_vec!(
          w_vec,
          w.witness.clone());
        define!(
          n_1,
          n);
        redefine_zero_pad_concat_vector!(
          w_vec,
          n_1,
          delta_vec);
        define_commit_vector!(
          cm_w_vec,
          w_vec,
          pk.powers,
          n_1 + 1);
        define!(
          maxshift,
          2);
        get_randomness_from_hash!(
          alpha,
          one!(),
          cm_w_vec);
        define_vec!(
          t_vec,
          vector_concat!(
          delta_vec_1,
          expression_vector!(
          i,
          vector_index!(
          w_vec,
          minus_i64!(
          i + n_1,
          1))*(delta!(
          i + n_1,
          1) + delta!(
          i + n_1,
          2) + delta!(
          i + n_1,
          n)) - range_index!(
          1,
          n,
          i + n_1)*(aplus2b*delta!(
          i + n_1,
          2) + c*delta!(
          i + n_1,
          n) + delta!(
          i + n_1,
          1)*(a + b)),
          maxshift + 2)));
        define_commit_vector!(
          cm_t_vec,
          t_vec,
          pk.powers,
          maxshift + 2);
        get_randomness_from_hash!(
          omega,
          one!(),
          cm_w_vec,
          cm_t_vec);
        define!(
          c_1,
          omega.inverse().unwrap());
        define_vector_reverse_omega_shift!(
          v_vec,
          w_vec,
          omega,
          shiftlength);
        define_vector_power_mul!(
          v_vec_1,
          v_vec,
          one!(),
          n);
        define_vector_power_mul!(
          v_vec_2,
          t_vec,
          c_1,
          3);
        define!(
          c_2,
          -alpha*(omega + neg!(one!())) + one!());
        define!(
          c_3,
          alpha + one!());
        define!(
          c_4,
          -alpha*omega*(omega + one!()));
        define!(
          c_5,
          -alpha*power(omega, 2));
        define!(
          c_6,
          -a - b);
        define!(
          c_7,
          -aplus2b*omega);
        define!(
          c_8,
          -c*power(omega, n - 1));
        define!(
          c_9,
          alpha*omega);
        define!(
          c_10,
          alpha*power(omega, 2));
        define!(
          c_11,
          -alpha);
        define!(
          c_12,
          -power(omega, n + 2));
        define_expression_vector!(
          h_vec_1,
          i,
          c_10*vector_index!(
          v_vec_1,
          minus_i64!(
          i - maxshift - n_1,
          -shiftlength - 1)) + c_11*vector_index!(
          v_vec_1,
          minus_i64!(
          i - maxshift - n_1,
          1 - shiftlength)) + c_12*vector_index!(
          v_vec_2,
          minus_i64!(
          i - maxshift - n_1,
          -2)) + c_2*vector_index!(
          v_vec,
          minus_i64!(
          i - maxshift - n_1,
          1 - shiftlength)) + c_3*vector_index!(
          v_vec,
          minus_i64!(
          i - maxshift - n_1,
          2 - shiftlength)) + c_4*vector_index!(
          v_vec,
          minus_i64!(
          i - maxshift - n_1,
          -shiftlength)) + c_5*vector_index!(
          v_vec,
          minus_i64!(
          i - maxshift - n_1,
          -shiftlength - 1)) + c_6*range_index!(
          1,
          n,
          minus_i64!(
          i - maxshift - n_1,
          1)) + c_7*range_index!(
          1,
          n,
          minus_i64!(
          i - maxshift - n_1,
          0)) + c_8*range_index!(
          1,
          n,
          minus_i64!(
          i - maxshift - n_1,
          2 - n)) + c_9*vector_index!(
          v_vec_1,
          minus_i64!(
          i - maxshift - n_1,
          -shiftlength)) + vector_index!(
          v_vec,
          minus_i64!(
          i - maxshift - n_1,
          n - shiftlength)),
          maxshift + n_1);
        define_expression_vector!(
          h_vec_2,
          i,
          c_10*vector_index!(
          v_vec_1,
          minus_i64!(
          i + 1,
          -shiftlength - 1)) + c_11*vector_index!(
          v_vec_1,
          minus_i64!(
          i + 1,
          1 - shiftlength)) + c_12*vector_index!(
          v_vec_2,
          minus_i64!(
          i + 1,
          -2)) + c_2*vector_index!(
          v_vec,
          minus_i64!(
          i + 1,
          1 - shiftlength)) + c_3*vector_index!(
          v_vec,
          minus_i64!(
          i + 1,
          2 - shiftlength)) + c_4*vector_index!(
          v_vec,
          minus_i64!(
          i + 1,
          -shiftlength)) + c_5*vector_index!(
          v_vec,
          minus_i64!(
          i + 1,
          -shiftlength - 1)) + c_6*range_index!(
          1,
          n,
          minus_i64!(
          i + 1,
          1)) + c_7*range_index!(
          1,
          n,
          minus_i64!(
          i + 1,
          0)) + c_8*range_index!(
          1,
          n,
          minus_i64!(
          i + 1,
          2 - n)) + c_9*vector_index!(
          v_vec_1,
          minus_i64!(
          i + 1,
          -shiftlength)) + vector_index!(
          v_vec,
          minus_i64!(
          i + 1,
          n - shiftlength)),
          maxshift + n_1);
        define_commit_vector!(
          cm_h_vec_1,
          h_vec_1,
          pk.powers,
          cap_d);
        define_commit_vector!(
          cm_h_vec_2,
          h_vec_2,
          pk.powers,
          maxshift + n_1);
        get_randomness_from_hash!(
          z,
          one!(),
          cm_w_vec,
          cm_t_vec,
          cm_h_vec_1,
          cm_h_vec_2);
        define_eval_vector_expression!(
          y,
          omega/z,
          i,
          vector_index!(
          w_vec,
          i),
          n_1 + 1);
        define!(
          c_13,
          (-alpha*y*(power(omega, 2) + omega*z - one!()*power(z, 2))*(one!()*(one!() - z) - one!()*(one!() - power(z, n)) + z*(one!() - z)) + one!()*y*power(z, 2)*(one!() - z)*(one!() + z + power(z, n - 1)) - one!()*z*(one!() - power(z, n))*(aplus2b*omega + z*(c*power(omega/z, n - 1) + one!()*(a + b))))/(power(z, 2)*(one!() - z)));
        define!(
          c_14,
          power(z, n_1 - 3)*power(omega/z, n)*(-power(omega, 3) + one!()*power(z, 3))/(omega - one!()*z));
        define!(
          c_15,
          -power(z, -cap_d));
        define!(
          c_16,
          -z);
        define_vec_mut!(
          g_vec,
          expression_vector!(
          i,
          linear_combination_base_zero!(
          c_14,
          vector_index!(
          t_vec,
          i),
          c_15,
          vector_index!(
          h_vec_1,
          -cap_d + i + maxshift + n_1),
          c_16,
          vector_index!(
          h_vec_2,
          i)),
          cap_d));
        add_to_first_item!(
          g_vec,
          c_13);
        define_commitment_linear_combination!(
          cm_g,
          vk,
          c_13,
          cm_t_vec,
          c_14,
          cm_h_vec_1,
          c_15,
          cm_h_vec_2,
          c_16);
        define_poly_from_vec!(
          w_vec_poly,
          w_vec);
        define_poly_from_vec!(
          g_poly,
          g_vec);
        check_poly_eval!(
          g_poly,
          z,
          zero!(),
          "g does not evaluate to 0 at z");
        define!(
          fs,
          vec!(
          w_vec_poly));
        define!(
          gs,
          vec!(
          g_poly));
        get_randomness_from_hash!(
          rand_xi,
          one!(),
          cm_w_vec,
          cm_t_vec,
          cm_h_vec_1,
          cm_h_vec_2,
          cm_g,
          omega/z,
          y,
          z);
        get_randomness_from_hash!(
          rand_xi_2,
          scalar_to_field!(
          2),
          cm_w_vec,
          cm_t_vec,
          cm_h_vec_1,
          cm_h_vec_2,
          cm_g,
          omega/z,
          y,
          z);
        define!(
          z1,
          omega/z);
        define!(
          z2,
          z);
        
    let (cap_w, cap_w_1) = KZG10::batch_open(&pk.powers, &fs, &gs, &z1, &z2, &rand_xi, &rand_xi_2)?;
    Ok(FibonacciProof::<E> {
            cm_w_vec: cm_w_vec,
            cm_t_vec: cm_t_vec,
            cm_h_vec_1: cm_h_vec_1,
            cm_h_vec_2: cm_h_vec_2,
            y: y,
            cap_w: cap_w,
            cap_w_1: cap_w_1,
        })
  }
  fn verify(vk: &Self::VK, x: &Self::Ins, proof: &Self::Pf) -> Result<(), Error> {
    let size = vk.size.clone();
    let cap_d = vk.degree_bound as i64;
    let rng = &mut test_rng();
    let cm_w_vec = proof.cm_w_vec;
        let cm_t_vec = proof.cm_t_vec;
        let cm_h_vec_1 = proof.cm_h_vec_1;
        let cm_h_vec_2 = proof.cm_h_vec_2;
        let y = proof.y;
        let cap_w = proof.cap_w;
        let cap_w_1 = proof.cap_w_1;init_size!(
          n,
          n,
          size);
        define_generator!(
          gamma,
          E);
        init_size!(
          n,
          n,
          size);
        define!(
          a,
          x.a);
        define!(
          b,
          x.b);
        define!(
          c,
          x.c);
        define!(
          aplus2b,
          a + scalar_to_field!(2)*b);
        define!(
          n_1,
          n);
        get_randomness_from_hash!(
          alpha,
          one!(),
          cm_w_vec);
        get_randomness_from_hash!(
          omega,
          one!(),
          cm_w_vec,
          cm_t_vec);
        get_randomness_from_hash!(
          z,
          one!(),
          cm_w_vec,
          cm_t_vec,
          cm_h_vec_1,
          cm_h_vec_2);
        define!(
          c_13,
          (-alpha*y*(power(omega, 2) + omega*z - one!()*power(z, 2))*(one!()*(one!() - z) - one!()*(one!() - power(z, n)) + z*(one!() - z)) + one!()*y*power(z, 2)*(one!() - z)*(one!() + z + power(z, n - 1)) - one!()*z*(one!() - power(z, n))*(aplus2b*omega + z*(c*power(omega/z, n - 1) + one!()*(a + b))))/(power(z, 2)*(one!() - z)));
        define!(
          c_14,
          power(z, n_1 - 3)*power(omega/z, n)*(-power(omega, 3) + one!()*power(z, 3))/(omega - one!()*z));
        define!(
          c_15,
          -power(z, -cap_d));
        define!(
          c_16,
          -z);
        define_commitment_linear_combination!(
          cm_g,
          vk,
          c_13,
          cm_t_vec,
          c_14,
          cm_h_vec_1,
          c_15,
          cm_h_vec_2,
          c_16);
        define!(
          z1,
          omega/z);
        define!(
          z2,
          z);
        get_randomness_from_hash!(
          rand_xi,
          one!(),
          cm_w_vec,
          cm_t_vec,
          cm_h_vec_1,
          cm_h_vec_2,
          cm_g,
          omega/z,
          y,
          z);
        get_randomness_from_hash!(
          rand_xi_2,
          scalar_to_field!(
          2),
          cm_w_vec,
          cm_t_vec,
          cm_h_vec_1,
          cm_h_vec_2,
          cm_g,
          omega/z,
          y,
          z);
        define!(
          f_commitments,
          vec!(
          cm_w_vec));
        define!(
          g_commitments,
          vec!(
          cm_g));
        define!(
          f_values,
          vec!(
          y));
        define!(
          g_values,
          vec!(
          zero!()));
        
    if KZG10::<E, DensePoly<E::ScalarField>>::batch_check(
      &vk.kzg_vk,
      &f_commitments,
      &g_commitments,
      &z1,
      &z2,
      &rand_xi,
      &rand_xi_2,
      &f_values,
      &g_values,
      &cap_w,
      &cap_w_1,
      rng,
    )? {
      Ok(())
    } else {
      Err(Error::VerificationFail)
    }
  }
}

