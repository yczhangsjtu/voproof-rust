///! This file is generated by https://github.com/yczhangsjtu/voproof-rust/voproof-scripts/__init__.py
use super::*;

#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct RangeCheckProverKey<E: PairingEngine> {
  pub verifier_key: RangeCheckVerifierKey<E>,
  pub powers: Vec<E::G1Affine>,
  pub max_degree: u64,
  pub t_vec: Vec<E::ScalarField>,
}

#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct RangeCheckVerifierKey<E: PairingEngine> {
  pub cm_t_vec: Commitment<E>,
  pub kzg_vk: VerifierKey<E>,
  pub size: RangeCheckSize,
  pub degree_bound: u64,
}

#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct RangeCheckProof<E: PairingEngine> {
  pub cm_w_vec: Commitment<E>,
  pub cm_m_vec: Commitment<E>,
  pub cm_r_vec: Commitment<E>,
  pub cm_s_vec: Commitment<E>,
  pub cm_r_vec_tilde: Commitment<E>,
  pub cm_t_vec_1: Commitment<E>,
  pub cm_h_vec_1: Commitment<E>,
  pub cm_h_vec_2: Commitment<E>,
  pub y: E::ScalarField,
  pub y_1: E::ScalarField,
  pub y_2: E::ScalarField,
  pub cap_w: KZGProof<E>,
  pub cap_w_1: KZGProof<E>,
}

pub struct VOProofRangeCheck {}

impl<E: PairingEngine> SNARKProverKey<E> for RangeCheckProverKey<E> {}

impl<E: PairingEngine> SNARKVerifierKey<E> for RangeCheckVerifierKey<E> {}

impl<E: PairingEngine> SNARKProof<E> for RangeCheckProof<E> {}

impl VOProofRangeCheck {
  pub fn get_max_degree(size: RangeCheckSize) -> usize {
    (max!((size.lookup_size as i64), (size.range as i64))) as usize
  }
}

impl<E: PairingEngine> SNARK<E> for VOProofRangeCheck {
  type Size = RangeCheckSize;
  type CS = RangeCheck<E::ScalarField>;
  type PK = RangeCheckProverKey<E>;
  type VK = RangeCheckVerifierKey<E>;
  type Ins = RangeCheckInstance<E::ScalarField>;
  type Wit = RangeCheckWitness<E::ScalarField>;
  type Pf = RangeCheckProof<E>;

  fn setup(size: usize) -> Result<UniversalParams<E>, Error> {
    let rng = &mut test_rng();
    KZG10::<E, DensePoly<E::ScalarField>>::setup(size, rng)
  }

  fn index(
    pp: &UniversalParams<E>,
    cs: &RangeCheck<E::ScalarField>,
  ) -> Result<(RangeCheckProverKey<E>, RangeCheckVerifierKey<E>), Error> {
    let max_degree = Self::get_max_degree(cs.get_size());
    let cap_d = pp.powers_of_g.len();
    assert!(cap_d > max_degree);

    let powers_of_g = pp.powers_of_g[..].to_vec();
    let size = cs.get_size();
    init_size!(nsize, lookup_size, size);
    init_size!(range, range, size);
    define_generator!(gamma, E);
    init_size!(nsize, lookup_size, size);
    init_size!(range, range, size);
    define_vec!(
      t_vec,
      (0..range)
        .map(|x| to_field::<E::ScalarField>(x as u64))
        .collect::<Vec<_>>()
    );
    println!(
      "vector t_vec of length {} = 
[{}]",
      t_vec.len(),
      fmt_ff_vector!(t_vec)
    );
    define_commit_vector!(cm_t_vec, t_vec, powers_of_g, nsize);

    let verifier_key = RangeCheckVerifierKey::<E> {
      cm_t_vec: cm_t_vec,
      kzg_vk: VerifierKey {
        g: pp.powers_of_g[0],
        h: pp.h,
        beta_h: pp.beta_h,
        prepared_h: pp.prepared_h.clone(),
        prepared_beta_h: pp.prepared_beta_h.clone(),
      },
      size,
      degree_bound: cap_d as u64,
    };
    Ok((
      RangeCheckProverKey::<E> {
        verifier_key: verifier_key.clone(),
        powers: powers_of_g,
        max_degree: max_degree as u64,
        t_vec: t_vec,
      },
      verifier_key,
    ))
  }
  fn prove(pk: &Self::PK, x: &Self::Ins, w: &Self::Wit) -> Result<Self::Pf, Error> {
    let size = pk.verifier_key.size.clone();
    let vk = pk.verifier_key.clone();
    let cap_d = pk.verifier_key.degree_bound as i64;
    let rng = &mut test_rng();
    init_size!(nsize, lookup_size, size);
    init_size!(range, range, size);
    define_generator!(gamma, E);
    sample_randomizers!(
      rng,
      delta_vec,
      1,
      delta_vec_1,
      1,
      delta_vec_2,
      1,
      delta_vec_3,
      1,
      delta_vec_4,
      1,
      delta_vec_5,
      1
    );
    init_size!(range, range, size);
    init_size!(nsize, lookup_size, size);
    define_vec!(w_vec, w.witness.clone());
    define!(n, max!(nsize, range));
    redefine_zero_pad_concat_vector!(w_vec, n, delta_vec);
    define_commit_vector!(cm_w_vec, w_vec, pk.powers, n + 1);
    println!(
      "vector w_vec of length {} = \n[{}]",
      w_vec.len(),
      fmt_ff_vector!(w_vec)
    );
    define_vec!(m_vec, {
      let mut m = vec![zero!(); range as usize];
      for i in 0..(range as usize) {
        for j in 0..(nsize as usize) {
          if w_vec[j] == pk.t_vec[i] {
            m[i] += to_field::<E::ScalarField>(1);
          }
        }
      }
      m
    });
    redefine_zero_pad_concat_vector!(m_vec, n, delta_vec_1);
    define_commit_vector!(cm_m_vec, m_vec, pk.powers, n + 1);
    println!(
      "vector m_vec of length {} = \n[{}]",
      m_vec.len(),
      fmt_ff_vector!(m_vec)
    );
    get_randomness_from_hash!(beta, one!(), pk.verifier_key.cm_t_vec, cm_w_vec, cm_m_vec);
    define_vec!(r_vec, {
      let mut r = w_vec
        .iter()
        .take(nsize as usize)
        .map(|x| (*x + beta))
        .collect::<Vec<_>>();
      batch_inversion(&mut r);
      r
    });
    redefine_zero_pad_concat_vector!(r_vec, n, delta_vec_2);
    define_commit_vector!(cm_r_vec, r_vec, pk.powers, n + 1);
    println!(
      "vector r_vec of length {} = \n[{}]",
      r_vec.len(),
      fmt_ff_vector!(r_vec)
    );
    define_vec!(s_vec, {
      let mut s = pk
        .t_vec
        .iter()
        .take(range as usize)
        .map(|x| (*x + beta))
        .collect::<Vec<_>>();
      batch_inversion(&mut s);
      for i in 0..range {
        s[i as usize] *= m_vec[i as usize];
      }
      s
    });
    redefine_zero_pad_concat_vector!(s_vec, n, delta_vec_3);
    define_commit_vector!(cm_s_vec, s_vec, pk.powers, n + 1);
    println!(
      "vector s_vec of length {} = \n[{}]",
      s_vec.len(),
      fmt_ff_vector!(s_vec)
    );
    get_randomness_from_hash!(
      beta_1,
      one!(),
      pk.verifier_key.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec
    );
    define_expression_vector!(
      r_vec_1,
      i,
      power_linear_combination!(
        beta_1,
        minus!(
          mul!(vector_index!(r_vec, i), range_index!(1, nsize, i)),
          mul!(vector_index!(s_vec, i), range_index!(1, range, i))
        )
      ),
      n
    );
    define_concat_vector!(r_vec_tilde, accumulate_vector_plus!(r_vec_1), delta_vec_4);
    define_commit_vector!(cm_r_vec_tilde, r_vec_tilde, pk.powers, n + 1);
    define!(maxshift, 0);
    get_randomness_from_hash!(
      alpha,
      one!(),
      pk.verifier_key.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde
    );
    define!(c, -alpha);
    define!(c_1, power(alpha, 2));
    define!(c_2, -power(alpha, 2));
    define_vec!(
      t_vec_1,
      vector_concat!(
        delta_vec_5,
        expression_vector!(
          i,
          alpha
            * vector_index!(s_vec, minus_i64!(i + n, 1))
            * (beta * range_index!(1, range, minus_i64!(i + n, 1))
              + vector_index!(pk.t_vec, minus_i64!(i + n, 1)))
            + c * vector_index!(m_vec, minus_i64!(i + n, 1)) * range_index!(1, range, i + n)
            + c_1 * vector_index!(r_vec, minus_i64!(i + n, 1)) * range_index!(1, nsize, i + n)
            + c_2
              * range_index!(1, n, minus_i64!(i + n, 1))
              * (vector_index!(r_vec_tilde, minus_i64!(i + n, 1))
                - vector_index!(r_vec_tilde, minus_i64!(i + n, 2)))
            + c_2 * vector_index!(s_vec, minus_i64!(i + n, 1)) * range_index!(1, range, i + n)
            + vector_index!(r_vec, minus_i64!(i + n, 1))
              * (beta * range_index!(1, nsize, minus_i64!(i + n, 1))
                + vector_index!(w_vec, minus_i64!(i + n, 1)))
            - range_index!(1, nsize, minus_i64!(i + n, 1)) * range_index!(1, nsize, i + n),
          maxshift + 2
        )
      )
    );
    define_commit_vector!(cm_t_vec_1, t_vec_1, pk.powers, maxshift + 2);
    get_randomness_from_hash!(
      omega,
      one!(),
      pk.verifier_key.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1
    );
    define_mut!(sum_vec, vec!(zero!(); (maxshift + n + 1) as usize));
    define_mut!(
      hcheck_vec,
      vec!(zero!(); (2 * maxshift + 2 * n + 1) as usize)
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        vector_index!(r_vec, minus_i64!(i, 1)),
        beta * range_index!(1, nsize, minus_i64!(i, 1)) + vector_index!(w_vec, minus_i64!(i, 1))
      )
    );
    define_vector_domain_evaluations_dict!(_r_vec_left_eval_dict, _r_vec_right_eval_dict);
    define_vector_domain_evaluations_dict!(_w_vec_left_eval_dict, _w_vec_right_eval_dict);
    define_vector_poly_mul_shift!(
      v_vec,
      r_vec,
      w_vec,
      omega,
      shiftlength,
      _r_vec_left_eval_dict,
      _w_vec_right_eval_dict
    );
    define_vector_reverse_omega_shift!(v_vec_1, r_vec, omega, shiftlength_1);
    define_vector_power_mul!(v_vec_2, v_vec_1, one!(), nsize);
    // The vector pair here is \vec{r} and \vec{w}+\beta\cdot \vec{1}^{nsize}
    define_expression_vector!(
      atimesb_vec,
      i,
      beta * vector_index!(v_vec_2, minus_i64!(i - maxshift - n, 1 - shiftlength_1))
        + vector_index!(v_vec, minus_i64!(i - maxshift - n, 1 - shiftlength)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec,
      expression_vector!(i, vector_index!(r_vec, minus_i64!(i, 1)), maxshift + n + 1),
      expression_vector!(
        i,
        beta * range_index!(1, nsize, minus_i64!(i, 1)) + vector_index!(w_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec);
    check_vector_eq!(
      atimesb_vec,
      zero_pad!(abnaive_vec, 2 * maxshift + 2 * n + 1),
      "The 1'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        -range_index!(1, nsize, minus_i64!(i, 1)),
        range_index!(1, nsize, minus_i64!(i, 1))
      )
    );
    define!(c_3, power(omega, -1));
    define_power_power_mul!(v_vec_3, c_3, nsize, one!(), nsize);
    // The vector pair here is -\vec{1}^{nsize} and \vec{1}^{nsize}
    define!(c_4, -power(omega, nsize - 1));
    define_expression_vector!(
      atimesb_vec_1,
      i,
      c_4 * vector_index!(v_vec_3, minus_i64!(i - maxshift - n, 2 - nsize)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_1,
      expression_vector!(
        i,
        -range_index!(1, nsize, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      expression_vector!(
        i,
        range_index!(1, nsize, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_1);
    check_vector_eq!(
      atimesb_vec_1,
      zero_pad!(abnaive_vec_1, 2 * maxshift + 2 * n + 1),
      "The 2'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        alpha * vector_index!(s_vec, minus_i64!(i, 1)),
        beta * range_index!(1, range, minus_i64!(i, 1)) + vector_index!(pk.t_vec, minus_i64!(i, 1))
      )
    );
    define_vector_domain_evaluations_dict!(_s_vec_left_eval_dict, _s_vec_right_eval_dict);
    define_vector_domain_evaluations_dict!(_pk_t_vec_left_eval_dict, _pk_t_vec_right_eval_dict);
    define_vector_poly_mul_shift!(
      v_vec_4,
      s_vec,
      pk.t_vec,
      omega,
      shiftlength_2,
      _s_vec_left_eval_dict,
      _pk_t_vec_right_eval_dict
    );
    define_vector_reverse_omega_shift!(v_vec_5, s_vec, omega, shiftlength_3);
    define_vector_power_mul!(v_vec_6, v_vec_5, one!(), range);
    // The vector pair here is \alpha\cdot \vec{s} and \vec{t}+\beta\cdot \vec{1}^{range}
    define!(c_5, alpha * beta);
    define_expression_vector!(
      atimesb_vec_2,
      i,
      alpha * vector_index!(v_vec_4, minus_i64!(i - maxshift - n, 1 - shiftlength_2))
        + c_5 * vector_index!(v_vec_6, minus_i64!(i - maxshift - n, 1 - shiftlength_3)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_2,
      expression_vector!(
        i,
        alpha * vector_index!(s_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      expression_vector!(
        i,
        beta * range_index!(1, range, minus_i64!(i, 1)) + vector_index!(pk.t_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_2);
    check_vector_eq!(
      atimesb_vec_2,
      zero_pad!(abnaive_vec_2, 2 * maxshift + 2 * n + 1),
      "The 3'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        c * vector_index!(m_vec, minus_i64!(i, 1)),
        range_index!(1, range, minus_i64!(i, 1))
      )
    );
    define_vector_reverse_omega_shift!(v_vec_7, m_vec, omega, shiftlength_4);
    define_vector_power_mul!(v_vec_8, v_vec_7, one!(), range);
    // The vector pair here is - \alpha\cdot \vec{m} and \vec{1}^{range}
    define_expression_vector!(
      atimesb_vec_3,
      i,
      c * vector_index!(v_vec_8, minus_i64!(i - maxshift - n, 1 - shiftlength_4)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_3,
      expression_vector!(
        i,
        c * vector_index!(m_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      expression_vector!(
        i,
        range_index!(1, range, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_3);
    check_vector_eq!(
      atimesb_vec_3,
      zero_pad!(abnaive_vec_3, 2 * maxshift + 2 * n + 1),
      "The 4'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        c_1 * vector_index!(r_vec, minus_i64!(i, 1)),
        range_index!(1, nsize, minus_i64!(i, 1))
      )
    );
    define_vector_reverse_omega_shift!(v_vec_9, r_vec, omega, shiftlength_5);
    define_vector_power_mul!(v_vec_10, v_vec_9, one!(), nsize);
    // The vector pair here is \alpha^{2}\cdot \vec{r} and \vec{1}^{nsize}
    define_expression_vector!(
      atimesb_vec_4,
      i,
      c_1 * vector_index!(v_vec_10, minus_i64!(i - maxshift - n, 1 - shiftlength_5)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_4,
      expression_vector!(
        i,
        c_1 * vector_index!(r_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      expression_vector!(
        i,
        range_index!(1, nsize, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_4);
    check_vector_eq!(
      atimesb_vec_4,
      zero_pad!(abnaive_vec_4, 2 * maxshift + 2 * n + 1),
      "The 5'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        c_2 * vector_index!(s_vec, minus_i64!(i, 1)),
        range_index!(1, range, minus_i64!(i, 1))
      )
    );
    define_vector_reverse_omega_shift!(v_vec_11, s_vec, omega, shiftlength_6);
    define_vector_power_mul!(v_vec_12, v_vec_11, one!(), range);
    // The vector pair here is - \alpha^{2}\cdot \vec{s} and \vec{1}^{range}
    define_expression_vector!(
      atimesb_vec_5,
      i,
      c_2 * vector_index!(v_vec_12, minus_i64!(i - maxshift - n, 1 - shiftlength_6)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_5,
      expression_vector!(
        i,
        c_2 * vector_index!(s_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      expression_vector!(
        i,
        range_index!(1, range, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_5);
    check_vector_eq!(
      atimesb_vec_5,
      zero_pad!(abnaive_vec_5, 2 * maxshift + 2 * n + 1),
      "The 6'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        c_2 * range_index!(1, n, minus_i64!(i, 1)),
        vector_index!(r_vec_tilde, minus_i64!(i, 1)) - vector_index!(r_vec_tilde, minus_i64!(i, 2))
      )
    );
    define_vector_power_mul!(v_vec_13, r_vec_tilde, c_3, max!(nsize, range));
    // The vector pair here is - \alpha^{2}\cdot \vec{1}^{\max\left(nsize, range\right)} and \tilde{\vec{r}}-{\tilde{\vec{r}}}^{\to 1}
    define!(c_6, -power(alpha, 2) * power(omega, max!(nsize, range) - 1));
    define!(c_7, power(alpha, 2) * power(omega, max!(nsize, range) - 1));
    define_expression_vector!(
      atimesb_vec_6,
      i,
      c_6
        * vector_index!(
          v_vec_13,
          minus_i64!(i - maxshift - n, 2 - max!(nsize, range))
        )
        + c_7
          * vector_index!(
            v_vec_13,
            minus_i64!(i - maxshift - n, 3 - max!(nsize, range))
          ),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_6,
      expression_vector!(
        i,
        c_2 * range_index!(1, n, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      expression_vector!(
        i,
        vector_index!(r_vec_tilde, minus_i64!(i, 1)) - vector_index!(r_vec_tilde, minus_i64!(i, 2)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_6);
    check_vector_eq!(
      atimesb_vec_6,
      zero_pad!(abnaive_vec_6, 2 * maxshift + 2 * n + 1),
      "The 7'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        power(alpha, 3) * delta!(i, n),
        vector_index!(r_vec_tilde, minus_i64!(i, 1))
      )
    );
    // The vector pair here is \alpha^{3}\cdot \vec{e}_{\max\left(nsize, range\right)} and \tilde{\vec{r}}
    define!(c_8, power(alpha, 3) * power(omega, max!(nsize, range) - 1));
    define_expression_vector!(
      atimesb_vec_7,
      i,
      c_8 * vector_index!(r_vec_tilde, minus_i64!(i - maxshift - n, 2 - n)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_7,
      expression_vector!(i, power(alpha, 3) * delta!(i, n), maxshift + n + 1),
      expression_vector!(
        i,
        vector_index!(r_vec_tilde, minus_i64!(i, 1)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_7);
    check_vector_eq!(
      atimesb_vec_7,
      zero_pad!(abnaive_vec_7, 2 * maxshift + 2 * n + 1),
      "The 8'th convolution is incorrect"
    );
    add_expression_vector_to_vector!(
      sum_vec,
      i,
      mul!(
        -range_index!(1, maxshift + 1, minus_i64!(i, n + 1)),
        vector_index!(t_vec_1, minus_i64!(i, n))
      )
    );
    define_vector_power_mul!(v_vec_14, t_vec_1, c_3, 1);
    // The vector pair here is -{\vec{1}^{1}}^{\to \max\left(nsize, range\right)} and {{\vec{t}}_{1}}^{\to \max\left(nsize, range\right) - 1}
    define!(c_9, -power(omega, max!(nsize, range)));
    define_expression_vector!(
      atimesb_vec_8,
      i,
      c_9 * vector_index!(v_vec_14, minus_i64!(i - maxshift - n, 0)),
      2 * maxshift + 2 * n + 1
    );
    define_vector_poly_mul_no_dict!(
      abnaive_vec_8,
      expression_vector!(
        i,
        -range_index!(1, maxshift + 1, minus_i64!(i, n + 1)),
        maxshift + n + 1
      ),
      expression_vector!(
        i,
        vector_index!(t_vec_1, minus_i64!(i, n)),
        maxshift + n + 1
      ),
      omega
    );
    add_vector_to_vector!(hcheck_vec, abnaive_vec_8);
    check_vector_eq!(
      atimesb_vec_8,
      zero_pad!(abnaive_vec_8, 2 * maxshift + 2 * n + 1),
      "The 9'th convolution is incorrect"
    );
    define_vector_domain_evaluations_dict!(_r_vec_left_eval_dict, _r_vec_right_eval_dict);
    define_vector_domain_evaluations_dict!(_w_vec_left_eval_dict, _w_vec_right_eval_dict);
    define_vector_poly_mul_shift!(
      v_vec_15,
      r_vec,
      w_vec,
      omega,
      shiftlength_7,
      _r_vec_left_eval_dict,
      _w_vec_right_eval_dict
    );
    define_vector_reverse_omega_shift!(v_vec_16, r_vec, omega, shiftlength_8);
    define_vector_domain_evaluations_dict!(_s_vec_left_eval_dict, _s_vec_right_eval_dict);
    define_vector_domain_evaluations_dict!(_pk_t_vec_left_eval_dict, _pk_t_vec_right_eval_dict);
    define_vector_poly_mul_shift!(
      v_vec_17,
      s_vec,
      pk.t_vec,
      omega,
      shiftlength_9,
      _s_vec_left_eval_dict,
      _pk_t_vec_right_eval_dict
    );
    define_vector_reverse_omega_shift!(v_vec_18, s_vec, omega, shiftlength_10);
    define_vector_reverse_omega_shift!(v_vec_19, m_vec, omega, shiftlength_11);
    define_vector_power_mul!(v_vec_20, v_vec_16, one!(), nsize);
    define_vector_power_mul!(v_vec_21, v_vec_18, one!(), range);
    define_vector_power_mul!(v_vec_22, v_vec_19, one!(), range);
    define_vector_power_mul!(v_vec_23, r_vec_tilde, c_3, max!(nsize, range));
    define_vector_power_mul!(v_vec_24, t_vec_1, c_3, 1);
    define_power_power_mul!(v_vec_25, c_3, nsize, one!(), nsize);
    define_mut!(h_osum, zero!());
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        vector_index!(r_vec, minus_i64!(i, 1)),
        beta * range_index!(1, nsize, minus_i64!(i, 1)) + vector_index!(w_vec, minus_i64!(i, 1))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        -range_index!(1, nsize, minus_i64!(i, 1)),
        range_index!(1, nsize, minus_i64!(i, 1))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        alpha * vector_index!(s_vec, minus_i64!(i, 1)),
        beta * range_index!(1, range, minus_i64!(i, 1)) + vector_index!(pk.t_vec, minus_i64!(i, 1))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        c * vector_index!(m_vec, minus_i64!(i, 1)),
        range_index!(1, range, minus_i64!(i, 1))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        c_1 * vector_index!(r_vec, minus_i64!(i, 1)),
        range_index!(1, nsize, minus_i64!(i, 1))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        c_2 * vector_index!(s_vec, minus_i64!(i, 1)),
        range_index!(1, range, minus_i64!(i, 1))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        c_2 * range_index!(1, n, minus_i64!(i, 1)),
        vector_index!(r_vec_tilde, minus_i64!(i, 1)) - vector_index!(r_vec_tilde, minus_i64!(i, 2))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        power(alpha, 3) * delta!(i, n),
        vector_index!(r_vec_tilde, minus_i64!(i, 1))
      ),
      maxshift + n + 1
    );
    h_osum += eval_vector_expression!(
      omega,
      i,
      mul!(
        -range_index!(1, maxshift + 1, minus_i64!(i, n + 1)),
        vector_index!(t_vec_1, minus_i64!(i, n))
      ),
      maxshift + n + 1
    );
    assert_eq!(h_osum, zero!());
    check_vector_eq!(
      sum_vec,
      vec!(zero!(); (n + 1) as usize),
      "sum of hadamards not zero"
    );
    define!(c_10, power(alpha, 2) + beta);
    define!(c_11, alpha * (-alpha + beta));
    define_expression_vector!(
      h_vec,
      i,
      alpha * vector_index!(v_vec_17, minus_i64!(i - maxshift - n, 1 - shiftlength_9))
        + c * vector_index!(v_vec_22, minus_i64!(i - maxshift - n, 1 - shiftlength_11))
        + c_10 * vector_index!(v_vec_20, minus_i64!(i - maxshift - n, 1 - shiftlength_8))
        + c_11 * vector_index!(v_vec_21, minus_i64!(i - maxshift - n, 1 - shiftlength_10))
        + c_4 * vector_index!(v_vec_25, minus_i64!(i - maxshift - n, 2 - nsize))
        + c_6
          * vector_index!(
            v_vec_23,
            minus_i64!(i - maxshift - n, 2 - max!(nsize, range))
          )
        + c_7
          * vector_index!(
            v_vec_23,
            minus_i64!(i - maxshift - n, 3 - max!(nsize, range))
          )
        + c_8 * vector_index!(r_vec_tilde, minus_i64!(i - maxshift - n, 2 - n))
        + c_9 * vector_index!(v_vec_24, minus_i64!(i - maxshift - n, 0))
        + vector_index!(v_vec_15, minus_i64!(i - maxshift - n, 1 - shiftlength_7)),
      2 * maxshift + 2 * n + 1
    );
    check_vector_eq!(h_vec, hcheck_vec, "h is not expected");
    define_expression_vector!(
      h_vec_1,
      i,
      alpha * vector_index!(v_vec_17, minus_i64!(i - maxshift - n, 1 - shiftlength_9))
        + c * vector_index!(v_vec_22, minus_i64!(i - maxshift - n, 1 - shiftlength_11))
        + c_10 * vector_index!(v_vec_20, minus_i64!(i - maxshift - n, 1 - shiftlength_8))
        + c_11 * vector_index!(v_vec_21, minus_i64!(i - maxshift - n, 1 - shiftlength_10))
        + c_4 * vector_index!(v_vec_25, minus_i64!(i - maxshift - n, 2 - nsize))
        + c_6
          * vector_index!(
            v_vec_23,
            minus_i64!(i - maxshift - n, 2 - max!(nsize, range))
          )
        + c_7
          * vector_index!(
            v_vec_23,
            minus_i64!(i - maxshift - n, 3 - max!(nsize, range))
          )
        + c_8 * vector_index!(r_vec_tilde, minus_i64!(i - maxshift - n, 2 - n))
        + c_9 * vector_index!(v_vec_24, minus_i64!(i - maxshift - n, 0))
        + vector_index!(v_vec_15, minus_i64!(i - maxshift - n, 1 - shiftlength_7)),
      maxshift + n
    );
    define_expression_vector!(
      h_vec_2,
      i,
      alpha * vector_index!(v_vec_17, minus_i64!(i + 1, 1 - shiftlength_9))
        + c * vector_index!(v_vec_22, minus_i64!(i + 1, 1 - shiftlength_11))
        + c_10 * vector_index!(v_vec_20, minus_i64!(i + 1, 1 - shiftlength_8))
        + c_11 * vector_index!(v_vec_21, minus_i64!(i + 1, 1 - shiftlength_10))
        + c_4 * vector_index!(v_vec_25, minus_i64!(i + 1, 2 - nsize))
        + c_6 * vector_index!(v_vec_23, minus_i64!(i + 1, 2 - max!(nsize, range)))
        + c_7 * vector_index!(v_vec_23, minus_i64!(i + 1, 3 - max!(nsize, range)))
        + c_8 * vector_index!(r_vec_tilde, minus_i64!(i + 1, 2 - n))
        + c_9 * vector_index!(v_vec_24, minus_i64!(i + 1, 0))
        + vector_index!(v_vec_15, minus_i64!(i + 1, 1 - shiftlength_7)),
      maxshift + n
    );
    check_vector_eq!(
      h_vec,
      vector_concat!(h_vec_1, vec!(zero!()), h_vec_2),
      "h != h1 || 0 || h2"
    );
    assert_eq!(
      alpha * vector_index!(v_vec_17, minus_i64!(1, 1 - shiftlength_9))
        + c * vector_index!(v_vec_22, minus_i64!(1, 1 - shiftlength_11))
        + c_10 * vector_index!(v_vec_20, minus_i64!(1, 1 - shiftlength_8))
        + c_11 * vector_index!(v_vec_21, minus_i64!(1, 1 - shiftlength_10))
        + c_4 * vector_index!(v_vec_25, minus_i64!(1, 2 - nsize))
        + c_6 * vector_index!(v_vec_23, minus_i64!(1, 2 - max!(nsize, range)))
        + c_7 * vector_index!(v_vec_23, minus_i64!(1, 3 - max!(nsize, range)))
        + c_8 * vector_index!(r_vec_tilde, minus_i64!(1, 2 - n))
        + c_9 * vector_index!(v_vec_24, minus_i64!(1, 0))
        + vector_index!(v_vec_15, minus_i64!(1, 1 - shiftlength_7)),
      zero!()
    );
    define_commit_vector!(cm_h_vec_1, h_vec_1, pk.powers, cap_d);
    define_commit_vector!(cm_h_vec_2, h_vec_2, pk.powers, maxshift + n);
    get_randomness_from_hash!(
      z,
      one!(),
      pk.verifier_key.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1,
      cm_h_vec_1,
      cm_h_vec_2
    );
    define_eval_vector_expression!(y, omega / z, i, vector_index!(r_vec, i), n + 1);
    define_eval_vector_expression!(y_1, omega / z, i, vector_index!(s_vec, i), n + 1);
    define_eval_vector_expression!(y_2, omega / z, i, vector_index!(m_vec, i), n + 1);
    define_vec_mut!(naive_vec_g, vec!(zero!(); (cap_d) as usize));
    assert_eq!(
      one!() * y,
      eval_vector_expression!(
        omega / z,
        i,
        vector_index!(r_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      )
    );
    define!(c_12, one!() * y);
    define!(c_13, beta * one!() * y);
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_12 * vector_index!(w_vec, minus_i64!(i, 1))
        + c_13 * range_index!(1, nsize, minus_i64!(i, 1))
    );
    assert_eq!(
      one!() * z * (one!() - power(omega / z, nsize)) / (omega - one!() * z),
      eval_vector_expression!(
        omega / z,
        i,
        -range_index!(1, nsize, minus_i64!(i, 1)),
        maxshift + n + 1
      )
    );
    define!(
      c_16,
      one!() * z * (one!() - power(omega / z, nsize)) / (omega - one!() * z)
    );
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_16 * range_index!(1, nsize, minus_i64!(i, 1))
    );
    assert_eq!(
      alpha * one!() * y_1,
      eval_vector_expression!(
        omega / z,
        i,
        alpha * vector_index!(s_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      )
    );
    define!(c_17, alpha * one!() * y_1);
    define!(c_18, alpha * beta * one!() * y_1);
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_17 * vector_index!(pk.t_vec, minus_i64!(i, 1))
        + c_18 * range_index!(1, range, minus_i64!(i, 1))
    );
    assert_eq!(
      -alpha * one!() * y_2,
      eval_vector_expression!(
        omega / z,
        i,
        c * vector_index!(m_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      )
    );
    define!(c_20, -alpha * one!() * y_2);
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_20 * range_index!(1, range, minus_i64!(i, 1))
    );
    assert_eq!(
      power(alpha, 2) * one!() * y,
      eval_vector_expression!(
        omega / z,
        i,
        c_1 * vector_index!(r_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      )
    );
    define!(c_21, power(alpha, 2) * one!() * y);
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_21 * range_index!(1, nsize, minus_i64!(i, 1))
    );
    assert_eq!(
      -power(alpha, 2) * one!() * y_1,
      eval_vector_expression!(
        omega / z,
        i,
        c_2 * vector_index!(s_vec, minus_i64!(i, 1)),
        maxshift + n + 1
      )
    );
    define!(c_22, -power(alpha, 2) * one!() * y_1);
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_22 * range_index!(1, range, minus_i64!(i, 1))
    );
    assert_eq!(
      power(alpha, 2) * one!() * z * (one!() - power(omega / z, max!(nsize, range)))
        / (omega - one!() * z),
      eval_vector_expression!(
        omega / z,
        i,
        c_2 * range_index!(1, n, minus_i64!(i, 1)),
        maxshift + n + 1
      )
    );
    define!(
      c_23,
      power(alpha, 2) * one!() * z * (one!() - power(omega / z, max!(nsize, range)))
        / (omega - one!() * z)
    );
    define!(
      c_24,
      power(alpha, 2) * one!() * z * (one!() - power(omega / z, max!(nsize, range)))
        / (-omega + one!() * z)
    );
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_23 * vector_index!(r_vec_tilde, minus_i64!(i, 1))
        + c_24 * vector_index!(r_vec_tilde, minus_i64!(i, 2))
    );
    assert_eq!(
      power(alpha, 3) * power(omega / z, max!(nsize, range) - 1),
      eval_vector_expression!(
        omega / z,
        i,
        power(alpha, 3) * delta!(i, n),
        maxshift + n + 1
      )
    );
    define!(
      c_26,
      power(alpha, 3) * power(omega / z, max!(nsize, range) - 1)
    );
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_26 * vector_index!(r_vec_tilde, minus_i64!(i, 1))
    );
    assert_eq!(
      -power(omega / z, max!(nsize, range)),
      eval_vector_expression!(
        omega / z,
        i,
        -range_index!(1, maxshift + 1, minus_i64!(i, n + 1)),
        maxshift + n + 1
      )
    );
    define!(c_27, -power(omega / z, max!(nsize, range)));
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      c_27 * vector_index!(t_vec_1, minus_i64!(i, n))
    );
    add_expression_vector_to_vector!(
      naive_vec_g,
      i,
      mul!(
        vector_index!(h_vec_1, minus_i64!(i, cap_d - maxshift - n + 1)),
        -power(z, -cap_d)
      )
    );
    add_expression_vector_to_vector!(naive_vec_g, i, mul!(vector_index!(h_vec_2, i), -z));
    assert_eq!(
      linear_combination_base_zero!(
        eval_vector_expression!(
          omega / z,
          i,
          vector_index!(r_vec, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          beta * range_index!(1, nsize, minus_i64!(i, 1)) + vector_index!(w_vec, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          -range_index!(1, nsize, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          range_index!(1, nsize, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          alpha * vector_index!(s_vec, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          beta * range_index!(1, range, minus_i64!(i, 1))
            + vector_index!(pk.t_vec, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          c * vector_index!(m_vec, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          range_index!(1, range, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          c_1 * vector_index!(r_vec, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          range_index!(1, nsize, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          c_2 * vector_index!(s_vec, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          range_index!(1, range, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          c_2 * range_index!(1, n, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          vector_index!(r_vec_tilde, minus_i64!(i, 1))
            - vector_index!(r_vec_tilde, minus_i64!(i, 2)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          power(alpha, 3) * delta!(i, n),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          vector_index!(r_vec_tilde, minus_i64!(i, 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          omega / z,
          i,
          -range_index!(1, maxshift + 1, minus_i64!(i, n + 1)),
          maxshift + n + 1
        ),
        eval_vector_expression!(
          z,
          i,
          vector_index!(t_vec_1, minus_i64!(i, n)),
          maxshift + n + 1
        )
      ),
      mul!(eval_vector_as_poly!(h_vec, z), power(z, -maxshift - n))
    );
    define!(c_14, power(one!(), 2) * y);
    define!(
      c_15,
      power(one!(), 2)
        * (z * (one!() - power(z, nsize)) * (one!() - power(omega / z, nsize))
          + (omega - one!() * z)
            * (power(alpha, 2)
              * (y * (one!() - power(z, nsize)) - y_1 * (one!() - power(z, range)))
              + alpha
                * (beta * y_1 * (one!() - power(z, range)) - y_2 * (one!() - power(z, range)))
              + beta * y * (one!() - power(z, nsize))))
        / ((omega - one!() * z) * (one!() - z))
    );
    define!(c_19, alpha * power(one!(), 2) * y_1);
    define!(
      c_25,
      power(alpha, 2)
        * one!()
        * (alpha * power(omega / z, max!(nsize, range) - 1) * (omega - one!() * z)
          + z * (one!() - z) * (one!() - power(omega / z, max!(nsize, range))))
        / (omega - one!() * z)
    );
    define!(
      c_28,
      -power(z, n - 1) * power(omega / z, max!(nsize, range))
    );
    define!(c_29, -power(z, -cap_d));
    define!(c_30, -z);
    define_vec_mut!(
      g_vec,
      expression_vector!(
        i,
        linear_combination_base_zero!(
          c_14,
          vector_index!(w_vec, i),
          c_19,
          vector_index!(pk.t_vec, i),
          c_25,
          vector_index!(r_vec_tilde, i),
          c_28,
          vector_index!(t_vec_1, i),
          c_29,
          vector_index!(h_vec_1, -cap_d + i + maxshift + n),
          c_30,
          vector_index!(h_vec_2, i)
        ),
        cap_d
      )
    );
    add_to_first_item!(g_vec, c_15);
    define_commitment_linear_combination!(
      cm_g,
      vk,
      c_15,
      cm_w_vec,
      c_14,
      vk.cm_t_vec,
      c_19,
      cm_r_vec_tilde,
      c_25,
      cm_t_vec_1,
      c_28,
      cm_h_vec_1,
      c_29,
      cm_h_vec_2,
      c_30
    );
    assert_eq!(cm_g, commit_vector!(g_vec, pk.powers, cap_d));
    define_poly_from_vec!(naive_vec_g_poly, naive_vec_g);
    check_poly_eval!(
      naive_vec_g_poly,
      z,
      zero!(),
      "naive g does not evaluate to 0 at z"
    );
    define_poly_from_vec!(r_vec_poly, r_vec);
    define_poly_from_vec!(s_vec_poly, s_vec);
    define_poly_from_vec!(m_vec_poly, m_vec);
    define_poly_from_vec!(g_poly, g_vec);
    check_poly_eval!(g_poly, z, zero!(), "g does not evaluate to 0 at z");
    define!(fs, vec!(r_vec_poly, s_vec_poly, m_vec_poly));
    define!(gs, vec!(g_poly));
    get_randomness_from_hash!(
      rand_xi,
      one!(),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1,
      cm_h_vec_1,
      cm_h_vec_2,
      cm_g,
      omega / z,
      y,
      y_1,
      y_2,
      z
    );
    get_randomness_from_hash!(
      rand_xi_2,
      scalar_to_field!(2),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1,
      cm_h_vec_1,
      cm_h_vec_2,
      cm_g,
      omega / z,
      y,
      y_1,
      y_2,
      z
    );
    define!(z1, omega / z);
    define!(z2, z);

    let (cap_w, cap_w_1) = KZG10::batch_open(&pk.powers, &fs, &gs, &z1, &z2, &rand_xi, &rand_xi_2)?;
    Ok(RangeCheckProof::<E> {
      cm_w_vec: cm_w_vec,
      cm_m_vec: cm_m_vec,
      cm_r_vec: cm_r_vec,
      cm_s_vec: cm_s_vec,
      cm_r_vec_tilde: cm_r_vec_tilde,
      cm_t_vec_1: cm_t_vec_1,
      cm_h_vec_1: cm_h_vec_1,
      cm_h_vec_2: cm_h_vec_2,
      y: y,
      y_1: y_1,
      y_2: y_2,
      cap_w: cap_w,
      cap_w_1: cap_w_1,
    })
  }
  fn verify(vk: &Self::VK, x: &Self::Ins, proof: &Self::Pf) -> Result<(), Error> {
    let size = vk.size.clone();
    let cap_d = vk.degree_bound as i64;
    let rng = &mut test_rng();
    let cm_w_vec = proof.cm_w_vec;
    let cm_m_vec = proof.cm_m_vec;
    let cm_r_vec = proof.cm_r_vec;
    let cm_s_vec = proof.cm_s_vec;
    let cm_r_vec_tilde = proof.cm_r_vec_tilde;
    let cm_t_vec_1 = proof.cm_t_vec_1;
    let cm_h_vec_1 = proof.cm_h_vec_1;
    let cm_h_vec_2 = proof.cm_h_vec_2;
    let y = proof.y;
    let y_1 = proof.y_1;
    let y_2 = proof.y_2;
    let cap_w = proof.cap_w;
    let cap_w_1 = proof.cap_w_1;
    init_size!(nsize, lookup_size, size);
    init_size!(range, range, size);
    define_generator!(gamma, E);
    init_size!(range, range, size);
    init_size!(nsize, lookup_size, size);
    define!(n, max!(nsize, range));
    get_randomness_from_hash!(beta, one!(), vk.cm_t_vec, cm_w_vec, cm_m_vec);
    get_randomness_from_hash!(
      beta_1,
      one!(),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec
    );
    get_randomness_from_hash!(
      alpha,
      one!(),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde
    );
    get_randomness_from_hash!(
      omega,
      one!(),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1
    );
    get_randomness_from_hash!(
      z,
      one!(),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1,
      cm_h_vec_1,
      cm_h_vec_2
    );
    define!(c_14, power(one!(), 2) * y);
    define!(
      c_15,
      power(one!(), 2)
        * (z * (one!() - power(z, nsize)) * (one!() - power(omega / z, nsize))
          + (omega - one!() * z)
            * (power(alpha, 2)
              * (y * (one!() - power(z, nsize)) - y_1 * (one!() - power(z, range)))
              + alpha
                * (beta * y_1 * (one!() - power(z, range)) - y_2 * (one!() - power(z, range)))
              + beta * y * (one!() - power(z, nsize))))
        / ((omega - one!() * z) * (one!() - z))
    );
    define!(c_19, alpha * power(one!(), 2) * y_1);
    define!(
      c_25,
      power(alpha, 2)
        * one!()
        * (alpha * power(omega / z, max!(nsize, range) - 1) * (omega - one!() * z)
          + z * (one!() - z) * (one!() - power(omega / z, max!(nsize, range))))
        / (omega - one!() * z)
    );
    define!(
      c_28,
      -power(z, n - 1) * power(omega / z, max!(nsize, range))
    );
    define!(c_29, -power(z, -cap_d));
    define!(c_30, -z);
    define_commitment_linear_combination!(
      cm_g,
      vk,
      c_15,
      cm_w_vec,
      c_14,
      vk.cm_t_vec,
      c_19,
      cm_r_vec_tilde,
      c_25,
      cm_t_vec_1,
      c_28,
      cm_h_vec_1,
      c_29,
      cm_h_vec_2,
      c_30
    );
    define!(z1, omega / z);
    define!(z2, z);
    get_randomness_from_hash!(
      rand_xi,
      one!(),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1,
      cm_h_vec_1,
      cm_h_vec_2,
      cm_g,
      omega / z,
      y,
      y_1,
      y_2,
      z
    );
    get_randomness_from_hash!(
      rand_xi_2,
      scalar_to_field!(2),
      vk.cm_t_vec,
      cm_w_vec,
      cm_m_vec,
      cm_r_vec,
      cm_s_vec,
      cm_r_vec_tilde,
      cm_t_vec_1,
      cm_h_vec_1,
      cm_h_vec_2,
      cm_g,
      omega / z,
      y,
      y_1,
      y_2,
      z
    );
    define!(f_commitments, vec!(cm_r_vec, cm_s_vec, cm_m_vec));
    define!(g_commitments, vec!(cm_g));
    define!(f_values, vec!(y, y_1, y_2));
    define!(g_values, vec!(zero!()));

    if KZG10::<E, DensePoly<E::ScalarField>>::batch_check(
      &vk.kzg_vk,
      &f_commitments,
      &g_commitments,
      &z1,
      &z2,
      &rand_xi,
      &rand_xi_2,
      &f_values,
      &g_values,
      &cap_w,
      &cap_w_1,
      rng,
    )? {
      Ok(())
    } else {
      Err(Error::VerificationFail)
    }
  }
}
